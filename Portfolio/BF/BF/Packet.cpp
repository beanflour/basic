#include "stdafx.h"
#include "Log.h"
#include "Packet.h"
#include "Range.h"

namespace BF
{
#pragma region	持失切/社瑚切
	CPacket::CPacket(void)
		:	mui_PacketType(0)
		,	mui_PullDataPos(0)
		,	mui_RTDataPos(0)
		,	mui_RTRealPos(0)
		,	mui_RealAddSize(0)
		,	mb_Lock(false)
	{
	}

	CPacket::CPacket(int const &_iPacketType)
		:	mui_PacketType( _iPacketType )
		,	mui_PullDataPos(0)
		,	mui_RTDataPos(0)
		,	mui_RTRealPos(0)
		,	mui_RealAddSize(0)
		,	mb_Lock(false)
	{
	}

	CPacket::CPacket(CPacket const &_Packet)
		:	mui_PacketType( _Packet.mui_PacketType )
		,	mui_PullDataPos( _Packet.mui_PullDataPos )
		,	mui_RTDataPos(_Packet.mui_RTDataPos)
		,	mui_RTRealPos(_Packet.mui_RTRealPos)
		,	mCont_Data( _Packet.mCont_Data )
		,	mui_RealAddSize(_Packet.mui_RealAddSize)
		,	mb_Lock(_Packet.mb_Lock)
	{
	}

	CPacket::~CPacket(void)
	{
		Clear();
	}

	void CPacket::Clear()
	{
		mb_Lock			= false;
		mui_PacketType	= 0;
		mui_PullDataPos	= 0;
		mui_RealAddSize	= 0;
		mui_RTDataPos	= 0;
		mui_RTRealPos	= 0;
		mCont_Data.clear();
		ReturnData.clear();
	}
#pragma endregion

#pragma region Append
	void CPacket::Append(int &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize	= sizeof(int);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(int const &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize	= sizeof(int);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(ULONG32 &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize	= sizeof(ULONG32);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(short &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize	= sizeof(short);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(__int64 &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize	= sizeof(__int64);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(ULONG64 &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(ULONG64);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(ULONG64 const &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(ULONG64);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(float &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(float);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(double &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(double);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(DWORD &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(DWORD);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(char &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(char);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(char const &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(char);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(wchar_t &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(wchar_t);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
	void CPacket::Append(wchar_t const &_Data)
	{
		if (mb_Lock)
			return;
		int const nAppendSize = sizeof(wchar_t);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], &_Data, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}

	void	CPacket::Append(void const *pData, ULONG64 const iDataSize)
	{
		if (mb_Lock)
			return;
		this->Append(iDataSize);

		int const nAppendSize = static_cast<int>(iDataSize);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], pData, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}

	void	CPacket::Append(char const *pData)
	{
		if (mb_Lock)
			return;
		ULONG64 const iDataSize = strlen( pData );
		*this << iDataSize;
		
		int const nAppendSize = static_cast<int>(iDataSize);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], pData, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}

	void	CPacket::Append(char *pData)
	{
		if (mb_Lock)
			return;
		ULONG64 const iDataSize = strlen( pData );
		*this << iDataSize;

		int const nAppendSize = static_cast<int>(iDataSize);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], pData, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}

	void	CPacket::Append(wchar_t const *pData)
	{
		if (mb_Lock)
			return;
		ULONG64 const iDataSize = wcslen( pData );
		*this << iDataSize;

		int const nAppendSize = static_cast<int>(iDataSize) * sizeof(wchar_t);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], pData, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}

	void	CPacket::Append(wchar_t *pData)
	{
		if (mb_Lock)
			return;
		ULONG64 const iDataSize = wcslen( pData );
		*this << iDataSize;

		int const nAppendSize = static_cast<int>(iDataSize) * sizeof(wchar_t);
		mCont_Data.resize(static_cast<ULONG32>(mui_RealAddSize) + nAppendSize);
		memcpy(&mCont_Data[static_cast<ULONG32>(mui_RealAddSize)], pData, nAppendSize);
		mui_RealAddSize += nAppendSize;
	}
#pragma endregion

#pragma region Pull
	bool	CPacket::Pull(void *pData, ULONG64 const iDataSize)
	{
		if(false == mb_Lock && false == CheckSize(iDataSize))
			return false;

		memcpy( pData, &mCont_Data[ static_cast<LONG>(mui_PullDataPos) ] , static_cast<LONG>(iDataSize) );

		mui_PullDataPos += iDataSize;
		return true;
	}

	bool CPacket::Pull(int &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(int)))
		{
			_Data = *reinterpret_cast<int const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);
			mui_PullDataPos += sizeof(int);
		}
		else
			return false;

		return true;
	}
	bool CPacket::Pull(ULONG32 &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(ULONG32)))
		{
			_Data = *reinterpret_cast<ULONG32 const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)] );
			mui_PullDataPos += sizeof(ULONG32);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(short &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(short)))
		{
			_Data = *reinterpret_cast<short const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);
			mui_PullDataPos += sizeof(short);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(__int64 &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(__int64)))
		{
			_Data = *reinterpret_cast<__int64 const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);
			mui_PullDataPos += sizeof(__int64);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(ULONG64 &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(ULONG64)))
		{
			_Data = *reinterpret_cast<ULONG64 const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)] );
			mui_PullDataPos += sizeof(ULONG64);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(float &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(float)))
		{
			_Data = *reinterpret_cast<float const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);
			mui_PullDataPos += sizeof(float);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(double &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(double)))
		{
			_Data = *reinterpret_cast<double const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);
			mui_PullDataPos += sizeof(double);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(DWORD &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(DWORD)))
		{
			_Data = *reinterpret_cast<DWORD const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);
			mui_PullDataPos += sizeof(DWORD);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(char &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(char)))
		{
			_Data = *reinterpret_cast<char const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);

			mui_PullDataPos += sizeof(char);
		}
		else
			return false;
		return true;
	}
	bool CPacket::Pull(wchar_t &_Data)
	{
		if(false == mb_Lock && CheckSize(sizeof(wchar_t)))
		{
			_Data = *reinterpret_cast<wchar_t const *>(&mCont_Data[static_cast<LONG>(mui_PullDataPos)]);

			mui_PullDataPos += sizeof(wchar_t);
		}
		else
			return false;
		return true;
	}

	bool	CPacket::Pull(char *pData, ULONG64 const iDataPullSize)
	{
		if(false == mb_Lock && CheckSize(iDataPullSize * sizeof(char)))
		{
			memcpy(pData, &mCont_Data[static_cast<LONG>(mui_PullDataPos)], static_cast<LONG>(iDataPullSize));
			pData[iDataPullSize] = '\0';

			mui_PullDataPos += iDataPullSize;
			return true;
		}
		else
			return false;
		return false;
	}

	bool CPacket::Pull(char *pData)
	{
		if(mb_Lock && !CheckSize(sizeof(ULONG64)))
			return false;

		ULONG64 iDataSize = 0;
		*this >> iDataSize;
		if(!CheckSize(iDataSize))
			return false;

		return this->Pull(pData, iDataSize);
	}
	bool	CPacket::Pull(wchar_t *pData, ULONG64 const iDataPullSize)
	{
		if(false == mb_Lock && CheckSize(iDataPullSize * sizeof(wchar_t)))
		{
			::memcpy(pData, &mCont_Data[static_cast<LONG32>(mui_PullDataPos)], static_cast<ULONG32>(iDataPullSize) * sizeof(wchar_t));
			pData[iDataPullSize] = L'\0';
			mui_PullDataPos += (iDataPullSize * sizeof(wchar_t));

			return true;
		}

		return false;
	}
	bool	CPacket::Pull(wchar_t *pData)
	{
		if(mb_Lock && !CheckSize(sizeof(ULONG64)))
			return false;

		ULONG64	uiLength = 0;
		*this >> uiLength;
		if(0 == uiLength)
			return false;

		return this->Pull(pData, uiLength);
	}
#pragma endregion

#pragma region GetData
	/*
		GetData澗 置企 D_SEND_LIMIT_SIZE + (sizeof(ULONG64)*3)滴奄幻鏑 汽戚斗研 条嬢紳陥.
		Packet税 穿端 紫戚綜亜 D_SEND_LIMIT_SIZE研 角聖井酔 置企 紫戚綜幻鏑生稽 歳拝馬食 return 廃陥.
		姥繕澗 伯希3鯵人 叔 汽戚斗稽 戚欠嬢閃 赤陥.
		伯希1. PacketType
		伯希2. 穿勺 汽戚斗 紫戚綜亜 D_SEND_LIMIT_SIZE研 角嬢哀 井酔 繕験馬奄 是廃 鳶填 腰硲陥.
			   0析井酔 舘偽packet. 0 戚雌析 井酔 歳拝汽戚展
		伯希3. 穿勺馬澗 汽戚斗 紫戚綜.
	*/
	char* CPacket::GetData()
	{
		if(mCont_Data.empty() || mCont_Data.size() == mui_RTRealPos)	//	鳶填拭 汽戚斗亜 蒸暗蟹, 乞窮 汽戚斗亜 送慶鉢鞠嬢 鋼崖鞠醸聖 井酔.
			return nullptr;

		ULONG64 const nULONG64Size	= sizeof(ULONG64);
		ULONG64 nDataSize			= GetRTRemnantSize();	//	穿勺背醤拝 害精 滴奄研 亜閃身.
		int nRTNumber				= 0;
		int nTotalNumber			= 0;
		int const nLocalSize		= static_cast<int>(mui_RTDataPos);
		/*	
			m_uiRTRealPos澗 薄仙猿走 穿勺廃 汽戚斗 Size戚糠稽 蟹勧 交戚 腰硲亜 吉陥.
			m_ContData.Size() / D_SEND_LIMIT_SIZE亜 0析井酔(蟹喚 琶推亜 蒸聖 井酔) 0
			蟹喚 琶推亜 赤聖井酔 叔薦 穿勺廃 汽戚斗(m_uiRTRealPos) / 穿勺亜管 紫戚綜(D_SEND_LIMIT_SIZE) + 1戚 鳶填 腰硲亜 鞠嬢
			腰硲授生稽 繕験廃陥.
		*/
		ULONG64 unRTNumber = 0;		// unRTNumber 腰硲亜 0析井酔 0.
		int const nAllDataSize = GetAllDataSize();
		if (D_SEND_LIMIT_SIZE < nAllDataSize)	//	歳拝拝 琶推亜 赤澗 汽戚斗析 井酔 呪舛拭 級嬢娃陥.
		{
			nRTNumber		= (static_cast<int>(mui_RTRealPos) / D_SEND_LIMIT_SIZE) + 1;
			nTotalNumber	= ((nAllDataSize % D_SEND_LIMIT_SIZE) == 0) ? (nAllDataSize / D_SEND_LIMIT_SIZE) : ((nAllDataSize / D_SEND_LIMIT_SIZE) + 1);
			unRTNumber ^= nRTNumber;	//	薄仙 角獄葵聖 隔製
			unRTNumber <<= sizeof(ULONG64) / 2 * 8;	//	ULONG64税 箭鋼滴奄幻鏑 獣覗闘廃陥.
			unRTNumber ^= nTotalNumber; //	穿端 角獄葵聖 隔製
		}

		//	穿勺背醤拝 害精 滴奄亜 廃腰拭 穿勺拝 滴奄研 角嬢哀 井酔 戚腰殖 穿勺亜管滴奄幻 穿勺敗.
		if (D_SEND_LIMIT_SIZE < nDataSize)
		{
			nDataSize = D_SEND_LIMIT_SIZE;
		}

		//	mb_Lock戚 照杏形赤澗 井酔澗 送慶鉢研 獣拙馬澗 井酔. ReturnData税 穿端滴奄研 層搾廃陥.
		if(false == mb_Lock)
		{
			mb_Lock = true;	//	送慶鉢亜 獣拙鞠醸聖凶 喰聖 闇陥.
			ReturnData.resize(nLocalSize + GetDivideAllRTSize());	//	穿端 紫戚綜研 舛搾廃陥.
		}
		::memcpy(&ReturnData[nLocalSize], &mui_PacketType, nULONG64Size);									//	伯球1. PacketType
		::memcpy(&ReturnData[nLocalSize + nULONG64Size], &unRTNumber, nULONG64Size);						//	伯球2. PacketNumber. 0腰析井酔 舘析鳶填. 1 戚雌析井酔 歳拝吉 鳶填戚陥.
		::memcpy(&ReturnData[nLocalSize + static_cast<LONG>(nULONG64Size * 2)], &nDataSize, nULONG64Size);	//	伯球3. DataSize.	穿勺拝 汽戚斗 紫戚綜.
		::memcpy(&ReturnData[nLocalSize + static_cast<LONG>(nULONG64Size * 3)], &mCont_Data[static_cast<size_t>(mui_RTRealPos)], static_cast<size_t>(nDataSize)); //	叔薦 汽戚斗

		mui_RTDataPos += static_cast<LONG32>(nDataSize + (nULONG64Size * 3));	//	穿勺廃 是帖研 痕井.
		mui_RTRealPos += nDataSize;		// 穿勺廃 叔薦 汽戚斗.
		
		//	穿端 汽戚斗税 送慶鉢亜 魁概聖 井酔. 喰聖 葱陥.
		if(GetAllDataSize() == mui_RTRealPos)
			mb_Lock = false;

		return &ReturnData[nLocalSize];
	}

	// D_SEND_LIMIT_SIZE人 淫域蒸澗 穿端 汽戚斗研 送慶鉢馬食 亜閃紳陥. 伯球 姥繕澗 旭陥.
	char* CPacket::GetAllData()
	{
		if(mCont_Data.empty())
			return nullptr;

		ULONG64 const nULONG64Size	= sizeof(ULONG64);
		ULONG64 const nDataSize		= mCont_Data.size();
		ULONG64 const unRTNumber	= 0;

		ReturnData.clear();
		ReturnData.resize(static_cast<size_t>((nULONG64Size * 3) + nDataSize));
		::memcpy(&ReturnData[0], &mui_PacketType, nULONG64Size);
		::memcpy(&ReturnData[nULONG64Size], &unRTNumber, nULONG64Size);
		::memcpy(&ReturnData[static_cast<LONG>(nULONG64Size * 2)], &nDataSize, nULONG64Size);
		::memcpy(&ReturnData[static_cast<LONG>(nULONG64Size * 3)], &mCont_Data[0], static_cast<size_t>(nDataSize));
		return &ReturnData[0];
	}

	//	級嬢赤澗 汽戚斗級戚 護鯵稽 歳拝馬食 穿勺背醤 馬澗走.
	int const CPacket::GetDivideCount() const
	{
		if(mCont_Data.empty())
			return 0;

		int const nAllDataSize = GetAllDataSize();
		int const nDivideCount = ((nAllDataSize % D_SEND_LIMIT_SIZE) == 0) ? (nAllDataSize / D_SEND_LIMIT_SIZE) : ((nAllDataSize / D_SEND_LIMIT_SIZE) + 1);

		return nDivideCount;
	}

	//	穿勺 亜管廃 是帖 痕井亜管. 巨虹闘澗 0
	bool CPacket::SetRTDataPos(ULONG64 const & _Pos /* = 0*/)
	{
		if(_Pos < mCont_Data.size())
			mui_RTRealPos = _Pos;
		return false;
	}

	//	薄仙猿走 穿勺廃 滴奄葵.
	ULONG64 CPacket::GetRTDataPos() const
	{
		return mui_RTRealPos;
	}
	int const CPacket::GetCallDataCount() const
	{
		if(0 != mui_RTRealPos)
			return ((static_cast<int>(mui_RTRealPos) / D_SEND_LIMIT_SIZE) + 1);

		return 0;
	}
	/*
		送慶鉢吉 汽戚斗研 増嬢隔澗汽 紫遂廃陥.
		BF::CPacket税 GetData蟹 GetAllData研 紫遂馬食 条嬢紳 char*幻 紫遂亜管馬陥. 績税税 匂昔斗研 隔生檎 訓展績 拭君亜 劾 呪 赤陥.
		return葵戚 E_PACKET_ERROR::Complete析 凶拭幻 Pull戚蟹 Append研 紫遂拝 呪 赤陥.
	*/
	E_PACKET_ERROR::Enum CPacket::AddData(char * _strData)
	{
		if (nullptr == _strData)
		{
			BF_LOG.AddLog("CPacket::AddData(...) 古鯵痕呪亜 搾醸陥.");
			return E_PACKET_ERROR::Error;
		}

		LONG const nULONG64Size		= sizeof(ULONG64);
		ULONG64 const uiPacketType	= *reinterpret_cast<ULONG64 const *>(&_strData[0]);					//	鳶填展脊
		ULONG64 uiNumber			= *reinterpret_cast<ULONG64 const *>(&_strData[nULONG64Size]);		//	汽戚展 角獄. 0析井酔 舘析鳶填. 焼諌井酔 歳拝汽戚斗.
		ULONG64 const uiDataSize	= *reinterpret_cast<ULONG64 const *>(&_strData[nULONG64Size * 2]);	//	叔薦 汽戚斗 Size.
		int nNumber = 0, nTotalNumber = 0;

		if (0 == uiDataSize)	//	閤精 DataSize亜 0析井酔 魁.
			return E_PACKET_ERROR::NonSize;

		if (false == mb_Lock)	//	喰戚 照杏形 赤陥澗闇 坦製生稽 AddData亜 硲窒鞠醸陥澗 税耕.
		{
			this->Clear();		//	薄仙 Packet聖 搾酔壱.
			mb_Lock = true;		//	喰聖 闇陥.
		}
		if (uiNumber)
		{
			//	恥 nTotalNumber鯵税 歳拝鳶填掻 nNumber腰属 鳶填戚虞澗 倶.
			nTotalNumber ^= uiNumber;				//	歳拝吉 穿端 姐呪
			uiNumber >>= sizeof(ULONG64) / 2 * 8;
			nNumber ^= uiNumber;					//	薄仙 鳶填税 腰硲.

			if (mCont_Data.size() < static_cast<size_t>(D_SEND_LIMIT_SIZE * nTotalNumber))
				mCont_Data.resize(
					nTotalNumber * D_SEND_LIMIT_SIZE	//	戚穿拭 級嬢娃 Size.
				);
		}
		else
		{
			nNumber = 1;	//	購税 memcpy拭辞 &m_ContData[0]生稽 幻級奄 是廃 左舛葵.
			mCont_Data.resize(static_cast<ULONG32>(uiDataSize));
		}

		::memcpy(&mCont_Data[(nNumber - 1) * D_SEND_LIMIT_SIZE]	//	(腰硲 -1 * D_SEND_LIMIT_SIZE) 是帖拭辞 
				, &_strData[nULONG64Size * 3]						//	伯希紫戚綜 及採斗.
				, static_cast<size_t>(uiDataSize));					//	汽戚斗 紫戚綜幻鏑 差紫.

		mui_PacketType = uiPacketType;	//	閤焼兜精 鳶填展脊 差紫.

		mui_RealAddSize += uiDataSize;	//	叔薦 Add吉 汽戚斗 滴奄.
		int const nApply = ((mui_RealAddSize % D_SEND_LIMIT_SIZE) == 0) ? (static_cast<int>(mui_RealAddSize) / D_SEND_LIMIT_SIZE) : ((static_cast<int>(mui_RealAddSize) / D_SEND_LIMIT_SIZE) + 1);
		if(uiNumber == 0 || nApply == nTotalNumber)		//	舘析鳶填戚暗蟹 拙穣廃 鳶填戚 穿端幻鏑析 井酔
		{
			mb_Lock		= false;				//	鳶填 姥失戚 刃戟鞠醸生糠稽 喰聖 葱陥.
			return E_PACKET_ERROR::Complete;	//	刃失吉 鳶填績聖 硝顕.
		}

		return E_PACKET_ERROR::Remnant;		//	焼送 刃失鞠走 省精 鳶填績聖 硝顕.
	}
#pragma endregion

#pragma region Packet Information
	//	鳶填 展脊聖 痕井廃陥.
	void CPacket::SetPacketType(ULONG64 const & _pType)
	{
		this->mui_PacketType = _pType;
	}
	//	鳶填 展脊聖 亜閃紳陥.
	ULONG64 const	CPacket::GetPacketType() const
	{
		return mui_PacketType;
	}
	//	穿勺拝 害精 鳶填 紫戚綜.
	int const CPacket::GetRTRemnantSize() const
	{
		return GetAllDataSize() - static_cast<int>(mui_RTRealPos);
	}
	/* 
		薄仙 GetData()研 紫遂馬檎 握壱 神惟 吃 紫戚綜
		GetData()左陥 蒋拭 紫遂鞠嬢醤 廃陥.
	*/
	int const CPacket::GetRTLocalSize() const
	{
		int nSize = GetRTRemnantSize();
		if(D_SEND_LIMIT_SIZE < nSize)
			nSize = D_SEND_LIMIT_SIZE;
		return nSize + (sizeof(ULONG64) * 3);
	}
	//	送慶鉢拝 穿端 紫戚綜. GetAllData()研 紫遂馬心聖 凶 握壱神惟吃 汽戚斗税 紫戚綜人 旭陥.
	int const	CPacket::GetAllRTDataSize() const
	{
		return ((sizeof(ULONG64) * 3) + GetAllDataSize());
	}

	bool		CPacket::CheckSize(unsigned int _iSize) const
	{
		//	鳶填拭 汽戚斗亜 蒸暗蟹, 薄仙 匙閃蟹娃 汽戚斗 + 皐哀 汽戚斗税 丞戚 穿端 汽戚斗税 紫戚綜研 段引拝 井酔, 皐哀 汽戚斗 丞戚 0析井酔 false
		if(mCont_Data.empty() || mui_PullDataPos + _iSize > /*m_ContData.size()*/mui_RealAddSize || 0 >= _iSize)		
			return false;

		return true;
	}

	bool		CPacket::CheckSize(ULONG64 _iSize) const
	{
		if(mCont_Data.empty() || mui_PullDataPos + _iSize > /*m_ContData.size()*/mui_RealAddSize || 0 == _iSize)
			return false;

		return true;
	}
	//	Packet拭 級嬢娃 穿端 汽戚斗 size研 閤澗陥.
	int const	CPacket::GetAllDataSize() const
	{
		return mCont_Data.size();
	}
	//	汽戚斗 珍砺戚格税 capacity研 耕軒 溌左廃陥.
	void CPacket::Reserve(ULONG64 const reserve_size)
	{
		if( 0 < reserve_size )
		{
			mCont_Data.reserve( static_cast<LONG>(reserve_size) );
		}
	}
	//	穿端 汽戚斗 滴奄研 歳拝馬心聖凶税 恥 汽戚斗 滴奄研 鋼発廃陥. 歳拝鞠澗 姐呪 * 伯球紫戚綜幻鏑 蓄亜吉陥.
	int const CPacket::GetDivideAllRTSize() const
	{
		int const nHeadSize		= sizeof(ULONG64) * 3;
		int const nAllDataSize	= GetAllDataSize();
		int const nHeadCount	= GetDivideCount();
		return ((nHeadSize * nHeadCount) + nAllDataSize);
	}
#pragma endregion

#pragma region Operator >>
	CPacket&	CPacket::operator >>(bool&	_Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket&	CPacket::operator >>(int&	_Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(unsigned int&	_Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(short& _Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(unsigned short _Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(__int64&			_Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(ULONG64&	_Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(float& _Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(double& _Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(DWORD& _Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(char&	_Data)
	{
		this->Pull(_Data);
		return *this;
	}
	CPacket& CPacket::operator >>(wchar_t& _Data)
	{
		this->Pull(_Data);
		return *this;
	}

	CPacket& CPacket::operator >>(char* pData)
	{
		this->Pull(pData);
		return *this;
	}
	CPacket& CPacket::operator >>(wchar_t* pData)
	{
		this->Pull(pData);
		return *this;
	}
	CPacket& CPacket::operator >>(std::string &strData)
	{
		this->Pull(strData);
		return *this;
	}
	CPacket& CPacket::operator >>(std::wstring & wstrData)
	{
		this->Pull(wstrData);
		return *this;
	}
#pragma endregion

#pragma region operator <<
	CPacket& CPacket::operator <<(bool _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(int _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(unsigned int _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(short _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(unsigned short _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(__int64 _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(ULONG64 _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(float _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(double _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(DWORD& _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(char&	_Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(wchar_t& _Data)
	{
		Append(_Data);
		return *this;
	}
	CPacket& CPacket::operator <<(char* pData)
	{
		Append(pData);
		return *this;
	}
	CPacket& CPacket::operator <<(std::string const & _strData)
	{
		Append(_strData);
		return *this;
	}
	CPacket& CPacket::operator <<(wchar_t* pData)
	{
		 Append(pData);
		return *this;
	}
	CPacket& CPacket::operator <<(std::wstring const & _wstrData)
	{
		Append(_wstrData);
		return *this;
	}
#pragma endregion
}